1、单一职责原则（Single Responsibility）
    一个类应该只负责一项职责。如果类A负责两个不同的职责：职责1、职责2。
当职责1需求变更而改变A时，可能造成职责2执行错误，所以需要将A的粒度分解为A1、A2。
细节：
    1.降低类的复杂度，一个类只负责一项职责。
    2.提高类的可读性，可维护性。
    3.降低类变更引起的风险。
    *4.通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级别
    违反单一职责原则；只有类中方法足够少，可以在方法级别保持单一职责原则。

2、接口隔离原则（Interface Segregation Principle）
    客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上。
如：类A依赖接口B，C是B的实现类，实现类C中不应该包含对类A不需要的方法的实现，接口B
应该只包含类A需要的方法，如果包含接口B中包含其他的方法，应当将接口B拆分有类A需要的方法
的接口。

3、依赖倒置原则（Dependence Inversion Principle）
    1.高层模块不应该依赖底层模块，二者应该依赖于抽象。
    *2.抽象不应该依赖细节，细节应该依赖于抽象。
    3.依赖倒置的中心思想是面向接口编程。
    4、依赖倒置的原则是基于：相对于细节的多变性，抽象的东西要稳定得多。以抽象为基础搭建的架构
    比以细节为基础的架构要稳定的多。
    *5.使用接口/抽象类的目的是制定好设计规范，而不涉及具体的操作，吧展现细节的任务交给
    它们的实现类去完成。
细节：
    1.底层模块尽量都要有抽象类/接口，或者二者都有，程序稳定性更好。
    *2.变量的声明类型尽量是抽象类/接口，这样对变量的引用和实际对象之间，存在一个缓冲层，
    有利于程序的扩展和优化。
    3.继承时遵循里氏替换原则。

4、里氏替换原则（Liskov Substitution Principle）
*继承存在问题：
    1.父类实现好的方法，子类会对这些方法进行修改，会对整个继承体系造成破坏。
    2.降低程序的可移植性，如果父类中的方法进行修改，可能会影响到其所有子类。

    1.如果每个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P
    在所有的对象o1都被替换成o2时，程序P的行为不会发生变化，那么T2是T1的子类型。
    *即所有引用基类的地方必须能够透明的引用其子类对象。
    2.在代码层次中，即子类中尽量不要重写父类中的代码。
    3.通常解决方案：可以使原父类和子类继承更通用的基类，破坏原有的继承关系，可以通过
    聚合，组合，依赖来解决问题。

5、开闭原则（Open Closed Principle）
    对扩展开放，对修改关闭。即通过扩展实体的行为实现变化，而不能通过修改已有代码实现变化。

6、迪米特法则（Demeter Principle）（最少知道原则）
    1.一个对象应该对其他对象的保持最少的了解。
    2.类与类关系越密切，耦合度越大。
    3.一个类对自己依赖的类知道的越少越好，也就是说，对于被依赖的类不管多复杂，都尽量
    将逻辑封装在类内部，对外提供public方法，不对外泄露任何信息。
    4.只与直接朋友通信。
    5.直接朋友：如果两个对象之间存在耦合关系，我们就说两个对象之间是朋友关系。耦合的方式
    如：依赖，关联，组合，聚合等。
    *成员变量，方法参数，方法返回值中额类为直接朋友，而出现在局部变量中的类不是直接朋友，
    陌生的类最好不要出现在类的内部。
细节：迪米特法则的核心是降低类之间的耦合，而不是要求完全没有依赖关系。

7、合成复用原则（Composite Reuse Principle）
    尽量使用组合/聚合，而不是继承。

设计模式：
1、单例模式（singleton）
2、工厂模式（factory）：简单工厂模式，工厂方法模式，抽象工厂模式
3、原型模式（prototype）
4、建造者模式（builder）
5、适配器模式（adapter）：类适配器，对象适配器，接口适配器
6、桥接模式（bridge）
7、装饰者模式（decorator）
8、组合模式（composite）
9、外观模式（facade）
10、代理模式（proxy）
11、享元模式（flyweight）
12、模板方法模式（template）
13、命令模式（command）
14、访问者模式（visitor）
15、迭代器模式（iterator）
16、观察者模式（observer）
17、中介者模式（mediator）